{"version":3,"names":["createRound","number","precision","methodName","func","Math","min","pair","split","Number","value","start","end","undefined","assertNumber","max"],"sources":["../../../../packages/util/math/round.ts","../../../../packages/util/math/in-range.ts"],"sourcesContent":["/**\n * Computes `number` rounded up to `precision`.\n *\n * 根据 `precision`（精度） 向上舍入 `number`。\n * ```ts\n * ceil(4.006); // 5\n * ceil(6.004, 2); // 6.01\n * ceil(6040, -2); // 6100\n * ```\n */\nexport function ceil(number: number, precision: number = 0): number {\n  return createRound(number, precision, 'ceil');\n}\n\n/**\n * Computes `number` rounded down to `precision`.\n *\n * 根据 `precision`（精度） 向下舍入 `number`。\n * ```ts\n * floor(4.006); // 4\n * floor(0.046, 2); // 0.04\n * floor(4060, -2); // 4000\n * ```\n */\nexport function floor(number: number, precision: number = 0): number {\n  return createRound(number, precision, 'floor');\n}\n\n/**\n * Computes `number` rounded to `precision`.\n *\n * 根据 `precision`（精度） 四舍五入 `number`。\n * ```ts\n * round(4.006); // 4\n * round(4.006, 2); // 4.01\n * round(4060, -2); // 4100\n * ```\n */\nexport function round(number: number, precision: number = 0): number {\n  return createRound(number, precision, 'round');\n}\n\nfunction createRound(number: number, precision: number, methodName: keyof Math): number {\n  const func = Math[methodName] as (x: number) => number;\n\n  precision = precision == null ? 0 : Math.min(precision, 292);\n  if (!precision) {\n    return func(number);\n  }\n  // Shift with exponential notation to avoid floating-point issues.\n  // See [MDN](https://mdn.io/round#Examples) for more details.\n  let pair = `${number}e`.split('e');\n  const value = func(Number(`${pair[0]}e${Number(pair[1]) + precision}`));\n  pair = `${value}e`.split('e');\n  return Number(`${pair[0]}e${Number(pair[1]) - precision}`);\n}\n","import { assertNumber } from '@delon/util/other';\n\n/**\n * Checks if `value` is between `start` and `end` to, but not including `end`. If `end` is not specified, it's set to start with `start` then set to `0`. If `start` is greater than `end` the params are swapped to support negative ranges.\n *\n * 检查 `value` 是否在 `start` 与 `end` 之间，但不包括 `end`。 如果 `end` 没有指定，那么 `start` 设置为 `0`。 如果 `start` 大于 `end`，那么参数会交换以便支持负范围。\n * ```ts\n * inRange(3, 2, 4); // true\n * inRange(4, 8); // true\n * inRange(4, 2); // false\n * inRange(2, 2); // false\n * inRange(1.2, 2); // true\n * inRange(-3, -2, -6); // true\n * ```\n */\nexport function inRange(value: number, start: number, end?: number): boolean {\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  assertNumber(value);\n  assertNumber(start);\n  assertNumber(end);\n  return value >= Math.min(start, end) && value < Math.max(start, end);\n}\n"],"mappings":"oYA0CA,SAASA,EAAYC,EAAgBC,EAAmBC,GACtD,IAAMC,EAAOC,KAAKF,GAGlB,KADAD,EAAyB,MAAbA,EAAoB,EAAIG,KAAKC,IAAIJ,EAAW,MAEtD,OAAOE,EAAKH,GAId,IAAIM,GAAUN,EAAM,KAAIO,MAAM,KAG9B,OADAD,GADcH,EAAKK,OAAUF,EAAK,GAAE,KAAIE,OAAOF,EAAK,IAAML,KACxC,KAACM,MAAM,KAClBC,OAAUF,EAAK,GAAE,KAAIE,OAAOF,EAAK,IAAML,I,OA5ChC,SAAKD,EAAgBC,GACnC,YADmC,IAAAA,MAAqB,GACjDF,EAAYC,EAAQC,EAAW,S,QAaxB,SAAMD,EAAgBC,GACpC,YADoC,IAAAA,MAAqB,GAClDF,EAAYC,EAAQC,EAAW,U,mBCVhBQ,EAAeC,EAAeC,GAQpD,YAPYC,IAARD,IACFA,EAAMD,EACNA,EAAQ,GAEVG,eAAaJ,GACbI,eAAaH,GACbG,eAAaF,GACNF,GAASL,KAAKC,IAAIK,EAAOC,IAAQF,EAAQL,KAAKU,IAAIJ,EAAOC,I,QDelD,SAAMX,EAAgBC,GACpC,YADoC,IAAAA,MAAqB,GAClDF,EAAYC,EAAQC,EAAW,U"}